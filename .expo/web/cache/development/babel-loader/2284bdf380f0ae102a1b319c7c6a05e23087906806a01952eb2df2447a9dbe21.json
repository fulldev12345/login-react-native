{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useCallback, useRef, useState } from \"react\";\nexport function useControlledState(value, defaultValue, onChange) {\n  var _useState = useState(value || defaultValue),\n    _useState2 = _slicedToArray(_useState, 2),\n    stateValue = _useState2[0],\n    setStateValue = _useState2[1];\n  var ref = useRef(value !== undefined);\n  var wasControlled = ref.current;\n  var isControlled = value !== undefined;\n  var stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(\"WARN: A component changed from \" + (wasControlled ? 'controlled' : 'uncontrolled') + \" to \" + (isControlled ? 'controlled' : 'uncontrolled') + \".\");\n  }\n  ref.current = isControlled;\n  var setValue = useCallback(function (value) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    var onChangeCaller = function onChangeCaller(value) {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          for (var _len2 = arguments.length, onChangeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            onChangeArgs[_key2 - 1] = arguments[_key2];\n          }\n          onChange.apply(void 0, [value].concat(onChangeArgs));\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n    if (typeof value === 'function') {\n      var updateFunction = function updateFunction(oldValue) {\n        for (var _len3 = arguments.length, functionArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          functionArgs[_key3 - 1] = arguments[_key3];\n        }\n        var interceptedValue = value.apply(void 0, [isControlled ? stateRef.current : oldValue].concat(functionArgs));\n        onChangeCaller.apply(void 0, [interceptedValue].concat(args));\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller.apply(void 0, [value].concat(args));\n    }\n  }, [isControlled, onChange]);\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n  return [value, setValue];\n}\nexport function clamp(value, min, max) {\n  if (min === void 0) {\n    min = -Infinity;\n  }\n  if (max === void 0) {\n    max = Infinity;\n  }\n  var newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\nexport function snapValueToStep(value, min, max, step) {\n  var remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  var snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n  var string = step.toString();\n  var index = string.indexOf('.');\n  var precision = index >= 0 ? string.length - index : 0;\n  if (precision > 0) {\n    var pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n  return snappedValue;\n}","map":{"version":3,"names":["useControlledState","value","defaultValue","onChange","_useState","useState","_useState2","_slicedToArray","stateValue","setStateValue","ref","useRef","undefined","wasControlled","current","isControlled","stateRef","console","warn","setValue","useCallback","_len","arguments","length","args","Array","_key","onChangeCaller","Object","is","_len2","onChangeArgs","_key2","apply","concat","updateFunction","oldValue","_len3","functionArgs","_key3","interceptedValue","clamp","min","max","Infinity","newValue","Math","snapValueToStep","step","remainder","isNaN","snappedValue","abs","sign","floor","string","toString","index","indexOf","precision","pow","round"],"sources":["E:\\Login-UI-UX-React-Native\\node_modules\\@react-stately\\utils\\dist\\packages\\@react-stately\\utils\\src\\useControlledState.ts","E:\\Login-UI-UX-React-Native\\node_modules\\@react-stately\\utils\\dist\\packages\\@react-stately\\utils\\src\\number.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T | ((prevState: T) => T), ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
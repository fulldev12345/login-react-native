{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { calculatePosition } from \"./calculatePosition\";\nimport { useCallback, useRef, useState } from 'react';\nimport { useCloseOnScroll } from \"./useCloseOnScroll\";\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\nvar visualViewport = typeof window !== 'undefined' && window.visualViewport;\nexport function useOverlayPosition(props) {\n  var direction = isRTL() ? 'rtl' : undefined;\n  var targetRef = props.targetRef,\n    overlayRef = props.overlayRef,\n    _props$scrollRef = props.scrollRef,\n    scrollRef = _props$scrollRef === void 0 ? overlayRef : _props$scrollRef,\n    _props$placement = props.placement,\n    placement = _props$placement === void 0 ? 'bottom' : _props$placement,\n    _props$containerPaddi = props.containerPadding,\n    containerPadding = _props$containerPaddi === void 0 ? 12 : _props$containerPaddi,\n    _props$shouldFlip = props.shouldFlip,\n    shouldFlip = _props$shouldFlip === void 0 ? true : _props$shouldFlip,\n    _props$boundaryElemen = props.boundaryElement,\n    boundaryElement = _props$boundaryElemen === void 0 ? typeof document !== 'undefined' ? document.body : null : _props$boundaryElemen,\n    _props$offset = props.offset,\n    offset = _props$offset === void 0 ? 0 : _props$offset,\n    _props$crossOffset = props.crossOffset,\n    crossOffset = _props$crossOffset === void 0 ? 0 : _props$crossOffset,\n    _props$shouldUpdatePo = props.shouldUpdatePosition,\n    shouldUpdatePosition = _props$shouldUpdatePo === void 0 ? true : _props$shouldUpdatePo,\n    _props$isOpen = props.isOpen,\n    isOpen = _props$isOpen === void 0 ? true : _props$isOpen,\n    _props$shouldOverlapW = props.shouldOverlapWithTrigger,\n    shouldOverlapWithTrigger = _props$shouldOverlapW === void 0 ? false : _props$shouldOverlapW,\n    onClose = props.onClose;\n  var _useState = useState({\n      position: {},\n      arrowOffsetLeft: undefined,\n      arrowOffsetTop: undefined,\n      maxHeight: undefined,\n      placement: undefined\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    position = _useState2[0],\n    setPosition = _useState2[1];\n  var deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, shouldOverlapWithTrigger];\n  var updatePosition = useCallback(function () {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n    setPosition(calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      shouldOverlapWithTrigger: shouldOverlapWithTrigger\n    }));\n  }, deps);\n  useLayoutEffect(updatePosition, deps);\n  useResize(updatePosition);\n  var isResizing = useRef(false);\n  useLayoutEffect(function () {\n    var timeout;\n    var onResize = function onResize() {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.addEventListener('resize', onResize);\n    return function () {\n      visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n  var close = useCallback(function () {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose ? close : undefined\n  });\n  return {\n    rendered: true,\n    overlayProps: {\n      style: _objectSpread(_objectSpread({\n        position: 'absolute',\n        zIndex: 100000\n      }, position.position), {}, {\n        maxHeight: position.maxHeight\n      })\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\nfunction useResize(onResize) {\n  useLayoutEffect(function () {\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}","map":{"version":3,"names":["calculatePosition","useCallback","useRef","useState","useCloseOnScroll","isRTL","useLayoutEffect","visualViewport","window","useOverlayPosition","props","direction","undefined","targetRef","overlayRef","_props$scrollRef","scrollRef","_props$placement","placement","_props$containerPaddi","containerPadding","_props$shouldFlip","shouldFlip","_props$boundaryElemen","boundaryElement","document","body","_props$offset","offset","_props$crossOffset","crossOffset","_props$shouldUpdatePo","shouldUpdatePosition","_props$isOpen","isOpen","_props$shouldOverlapW","shouldOverlapWithTrigger","onClose","_useState","position","arrowOffsetLeft","arrowOffsetTop","maxHeight","_useState2","_slicedToArray","setPosition","deps","current","updatePosition","translateRTL","overlayNode","targetNode","scrollNode","padding","useResize","isResizing","timeout","onResize","clearTimeout","setTimeout","addEventListener","removeEventListener","close","triggerRef","rendered","overlayProps","style","_objectSpread","zIndex","arrowProps","left","top","replace"],"sources":["E:\\Login-UI-UX-React-Native\\node_modules\\@react-native-aria\\overlays\\lib\\module\\web\\overlays\\src\\useOverlayPosition.ts"],"sourcesContent":["//@ts-nocheck\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { calculatePosition, PositionResult } from './calculatePosition';\nimport {\n  HTMLAttributes,\n  RefObject,\n  useCallback,\n  useRef,\n  useState,\n} from 'react';\nimport { Placement, PlacementAxis, PositionProps } from '@react-types/overlays';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\n\ninterface AriaPositionProps extends PositionProps {\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: HTMLElement;\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<HTMLElement>;\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<HTMLElement>;\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<HTMLElement>;\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean;\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void;\n  /** Determines whether the overlay should overlap with the trigger */\n  shouldOverlapWithTrigger?: boolean;\n}\n\ninterface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: HTMLAttributes<Element>;\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: HTMLAttributes<Element>;\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis;\n  /** Updates the position of the overlay. */\n  updatePosition(): void;\n}\n\n// @ts-ignore\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  const direction = isRTL() ? 'rtl' : undefined;\n  let {\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    shouldOverlapWithTrigger = false,\n    onClose,\n  } = props;\n  let [position, setPosition] = useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined,\n  });\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    shouldOverlapWithTrigger\n  ];\n\n  let updatePosition = useCallback(() => {\n    if (\n      shouldUpdatePosition === false ||\n      !isOpen ||\n      !overlayRef.current ||\n      !targetRef.current ||\n      !scrollRef.current ||\n      !boundaryElement\n    ) {\n      return;\n    }\n\n    setPosition(\n      calculatePosition({\n        placement: translateRTL(placement, direction),\n        overlayNode: overlayRef.current,\n        targetNode: targetRef.current,\n        scrollNode: scrollRef.current,\n        padding: containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        shouldOverlapWithTrigger,\n      })\n    );\n  }, deps);\n\n  // Update position when anything changes\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: NodeJS.Timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose ? close : undefined,\n  });\n\n  return {\n    rendered: true,\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight,\n      },\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop,\n      },\n    },\n    updatePosition,\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
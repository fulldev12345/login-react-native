{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { useLocale, useCollator } from \"@react-aria/i18n\";\nimport { focusWithoutScrolling, isMac, mergeProps } from \"@react-aria/utils\";\nimport { focusSafely, getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { useEffect, useRef, useMemo } from \"react\";\nimport _babelRuntimeHelpersEsmExtends from \"@babel/runtime/helpers/esm/extends\";\nexport function useTypeSelect(options) {\n  var keyboardDelegate = options.keyboardDelegate,\n    selectionManager = options.selectionManager,\n    onTypeSelect = options.onTypeSelect;\n  var state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n  var onKeyDown = function onKeyDown(e) {\n    var character = $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n    state.search += character;\n    var key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      state.search = '';\n    }, 500);\n  };\n  return {\n    typeSelectProps: {\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\nfunction $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(key) {\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n  return '';\n}\nfunction $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n  return e.ctrlKey;\n}\nexport function useSelectableCollection(options) {\n  var manager = options.selectionManager,\n    delegate = options.keyboardDelegate,\n    ref = options.ref,\n    _options$autoFocus = options.autoFocus,\n    autoFocus = _options$autoFocus === void 0 ? false : _options$autoFocus,\n    _options$shouldFocusW = options.shouldFocusWrap,\n    shouldFocusWrap = _options$shouldFocusW === void 0 ? false : _options$shouldFocusW,\n    _options$disallowEmpt = options.disallowEmptySelection,\n    disallowEmptySelection = _options$disallowEmpt === void 0 ? false : _options$disallowEmpt,\n    _options$disallowSele = options.disallowSelectAll,\n    disallowSelectAll = _options$disallowSele === void 0 ? false : _options$disallowSele,\n    _options$selectOnFocu = options.selectOnFocus,\n    selectOnFocus = _options$selectOnFocu === void 0 ? false : _options$selectOnFocu,\n    _options$disallowType = options.disallowTypeAhead,\n    disallowTypeAhead = _options$disallowType === void 0 ? false : _options$disallowType,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    _options$allowsTabNav = options.allowsTabNavigation,\n    allowsTabNavigation = _options$allowsTabNav === void 0 ? false : _options$allowsTabNav;\n  var _useLocale = useLocale(),\n    direction = _useLocale.direction;\n  var onKeyDown = function onKeyDown(e) {\n    if (e.altKey || !ref.current.contains(e.target)) {\n      return;\n    }\n    var navigateToKey = function navigateToKey(key, childFocus) {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n    switch (e.key) {\n      case 'ArrowDown':\n        {\n          if (delegate.getKeyBelow) {\n            e.preventDefault();\n            var nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey == null ? void 0 : delegate.getFirstKey();\n            if (nextKey == null && shouldFocusWrap) {\n              nextKey = delegate.getFirstKey == null ? void 0 : delegate.getFirstKey(manager.focusedKey);\n            }\n            navigateToKey(nextKey);\n          }\n          break;\n        }\n      case 'ArrowUp':\n        {\n          if (delegate.getKeyAbove) {\n            e.preventDefault();\n            var _nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey == null ? void 0 : delegate.getLastKey();\n            if (_nextKey == null && shouldFocusWrap) {\n              _nextKey = delegate.getLastKey == null ? void 0 : delegate.getLastKey(manager.focusedKey);\n            }\n            navigateToKey(_nextKey);\n          }\n          break;\n        }\n      case 'ArrowLeft':\n        {\n          if (delegate.getKeyLeftOf) {\n            e.preventDefault();\n            var _nextKey2 = delegate.getKeyLeftOf(manager.focusedKey);\n            navigateToKey(_nextKey2, direction === 'rtl' ? 'first' : 'last');\n          }\n          break;\n        }\n      case 'ArrowRight':\n        {\n          if (delegate.getKeyRightOf) {\n            e.preventDefault();\n            var _nextKey3 = delegate.getKeyRightOf(manager.focusedKey);\n            navigateToKey(_nextKey3, direction === 'rtl' ? 'last' : 'first');\n          }\n          break;\n        }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          var firstKey = delegate.getFirstKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          var lastKey = delegate.getLastKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          var _nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(_nextKey4);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          var _nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(_nextKey5);\n        }\n        break;\n      case 'a':\n        if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab':\n        {\n          if (!allowsTabNavigation) {\n            if (e.shiftKey) {\n              ref.current.focus();\n            } else {\n              var walker = getFocusableTreeWalker(ref.current, {\n                tabbable: true\n              });\n              var next;\n              var last;\n              do {\n                last = walker.lastChild();\n                if (last) {\n                  next = last;\n                }\n              } while (last);\n              if (next && !next.contains(document.activeElement)) {\n                focusWithoutScrolling(next);\n              }\n            }\n            break;\n          }\n        }\n    }\n  };\n  var onFocus = function onFocus(e) {\n    if (manager.isFocused) {\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n      return;\n    }\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      var relatedTarget = e.relatedTarget;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {\n        var _manager$lastSelected;\n        manager.setFocusedKey((_manager$lastSelected = manager.lastSelectedKey) != null ? _manager$lastSelected : delegate.getLastKey());\n      } else {\n        var _manager$firstSelecte;\n        manager.setFocusedKey((_manager$firstSelecte = manager.firstSelectedKey) != null ? _manager$firstSelecte : delegate.getFirstKey());\n      }\n    }\n  };\n  var onBlur = function onBlur(e) {\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      manager.setFocused(false);\n    }\n  };\n  useEffect(function () {\n    if (autoFocus) {\n      var focusedKey = null;\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      }\n      if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n      var selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n  }, []);\n  var handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown: function onMouseDown(e) {\n      if (e.currentTarget.contains(e.target)) {\n        e.preventDefault();\n      }\n    }\n  };\n  var _useTypeSelect = useTypeSelect({\n      keyboardDelegate: delegate,\n      selectionManager: manager\n    }),\n    typeSelectProps = _useTypeSelect.typeSelectProps;\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n  var tabIndex;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n  return {\n    collectionProps: _babelRuntimeHelpersEsmExtends({}, handlers, {\n      tabIndex: tabIndex\n    })\n  };\n}\nexport function useSelectableItem(options) {\n  var manager = options.selectionManager,\n    key = options.key,\n    ref = options.ref,\n    shouldSelectOnPressUp = options.shouldSelectOnPressUp,\n    isVirtualized = options.isVirtualized,\n    shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n    focus = options.focus;\n  var onSelect = function onSelect(e) {\n    return manager.select(key, e);\n  };\n  var isFocused = key === manager.focusedKey;\n  useEffect(function () {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  var itemProps = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n      onFocus: function onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n  if (shouldSelectOnPressUp) {\n    itemProps.onPressStart = function (e) {\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n    itemProps.onPressUp = function (e) {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n  } else {\n    itemProps.onPressStart = function (e) {\n      if (e.pointerType !== 'touch') {\n        onSelect(e);\n      }\n    };\n    itemProps.onPress = function (e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n      }\n    };\n  }\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n  return {\n    itemProps: itemProps\n  };\n}\nexport var ListKeyboardDelegate = function () {\n  function ListKeyboardDelegate(collection, disabledKeys, ref, collator) {\n    _classCallCheck(this, ListKeyboardDelegate);\n    this.collection = void 0;\n    this.disabledKeys = void 0;\n    this.ref = void 0;\n    this.collator = void 0;\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n  _createClass(ListKeyboardDelegate, [{\n    key: \"getKeyBelow\",\n    value: function getKeyBelow(key) {\n      key = this.collection.getKeyAfter(key);\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getKeyAbove\",\n    value: function getKeyAbove(key) {\n      key = this.collection.getKeyBefore(key);\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      var key = this.collection.getFirstKey();\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      var key = this.collection.getLastKey();\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) {\n          return key;\n        }\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.ref.current.querySelector(\"[data-key=\\\"\" + key + \"\\\"]\");\n    }\n  }, {\n    key: \"getKeyPageAbove\",\n    value: function getKeyPageAbove(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) {\n        return null;\n      }\n      var pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n      while (item && item.offsetTop > pageY) {\n        key = this.getKeyAbove(key);\n        item = this.getItem(key);\n      }\n      return key;\n    }\n  }, {\n    key: \"getKeyPageBelow\",\n    value: function getKeyPageBelow(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) {\n        return null;\n      }\n      var pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n      while (item && item.offsetTop < pageY) {\n        key = this.getKeyBelow(key);\n        item = this.getItem(key);\n      }\n      return key;\n    }\n  }, {\n    key: \"getKeyForSearch\",\n    value: function getKeyForSearch(search, fromKey) {\n      if (!this.collator) {\n        return null;\n      }\n      var collection = this.collection;\n      var key = fromKey || this.getFirstKey();\n      while (key != null) {\n        var item = collection.getItem(key);\n        var substring = item.textValue.slice(0, search.length);\n        if (item.textValue && this.collator.compare(substring, search) === 0) {\n          return key;\n        }\n        key = this.getKeyBelow(key);\n      }\n      return null;\n    }\n  }]);\n  return ListKeyboardDelegate;\n}();\nexport function useSelectableList(props) {\n  var selectionManager = props.selectionManager,\n    collection = props.collection,\n    disabledKeys = props.disabledKeys,\n    ref = props.ref,\n    keyboardDelegate = props.keyboardDelegate,\n    autoFocus = props.autoFocus,\n    shouldFocusWrap = props.shouldFocusWrap,\n    isVirtualized = props.isVirtualized,\n    disallowEmptySelection = props.disallowEmptySelection,\n    _props$selectOnFocus = props.selectOnFocus,\n    selectOnFocus = _props$selectOnFocus === void 0 ? false : _props$selectOnFocus,\n    disallowTypeAhead = props.disallowTypeAhead,\n    shouldUseVirtualFocus = props.shouldUseVirtualFocus,\n    allowsTabNavigation = props.allowsTabNavigation;\n  var collator = useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  var delegate = useMemo(function () {\n    return keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator);\n  }, [keyboardDelegate, collection, disabledKeys, ref, collator]);\n  useEffect(function () {\n    if (!isVirtualized && selectionManager.focusedKey && ref != null && ref.current) {\n      var element = ref.current.querySelector(\"[data-key=\\\"\" + selectionManager.focusedKey + \"\\\"]\");\n      if (element) {\n        $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(ref.current, element);\n      }\n    }\n  }, [isVirtualized, ref, selectionManager.focusedKey]);\n  var _useSelectableCollect = useSelectableCollection({\n      ref: ref,\n      selectionManager: selectionManager,\n      keyboardDelegate: delegate,\n      autoFocus: autoFocus,\n      shouldFocusWrap: shouldFocusWrap,\n      disallowEmptySelection: disallowEmptySelection,\n      selectOnFocus: selectOnFocus,\n      disallowTypeAhead: disallowTypeAhead,\n      shouldUseVirtualFocus: shouldUseVirtualFocus,\n      allowsTabNavigation: allowsTabNavigation\n    }),\n    collectionProps = _useSelectableCollect.collectionProps;\n  return {\n    listProps: collectionProps\n  };\n}\nfunction $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(scrollView, element) {\n  var offsetX = $a09ba753e08b703267f2392f7fc8e96$var$relativeOffset(scrollView, element, 'left');\n  var offsetY = $a09ba753e08b703267f2392f7fc8e96$var$relativeOffset(scrollView, element, 'top');\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n  var x = scrollView.scrollLeft;\n  var y = scrollView.scrollTop;\n  var maxX = x + scrollView.offsetWidth;\n  var maxY = y + scrollView.offsetHeight;\n  if (offsetX <= x) {\n    x = offsetX;\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= y) {\n    y = offsetY;\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\nfunction $a09ba753e08b703267f2392f7fc8e96$var$relativeOffset(ancestor, child, axis) {\n  var prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';\n  var sum = 0;\n  while (child.offsetParent) {\n    sum += child[prop];\n    if (child.offsetParent === ancestor) {\n      break;\n    } else if (child.offsetParent.contains(ancestor)) {\n      sum -= ancestor[prop];\n      break;\n    }\n    child = child.offsetParent;\n  }\n  return sum;\n}","map":{"version":3,"names":["useTypeSelect","options","keyboardDelegate","selectionManager","onTypeSelect","state","useRef","search","timeout","current","onKeyDown","e","character","$c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey","key","ctrlKey","metaKey","trim","length","preventDefault","stopPropagation","getKeyForSearch","focusedKey","setFocusedKey","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","getStringForKey","test","$a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed","isCtrlKeyPressed","isMac","useSelectableCollection","manager","delegate","ref","_options$autoFocus","autoFocus","_options$shouldFocusW","shouldFocusWrap","_options$disallowEmpt","disallowEmptySelection","_options$disallowSele","disallowSelectAll","_options$selectOnFocu","selectOnFocus","_options$disallowType","disallowTypeAhead","shouldUseVirtualFocus","_options$allowsTabNav","allowsTabNavigation","_useLocale","useLocale","direction","altKey","contains","target","navigateToKey","childFocus","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","nextKey","getFirstKey","getKeyAbove","getLastKey","getKeyLeftOf","getKeyRightOf","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","clearSelection","focus","walker","getFocusableTreeWalker","tabbable","next","last","lastChild","document","activeElement","focusWithoutScrolling","onFocus","isFocused","currentTarget","setFocused","relatedTarget","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","_manager$lastSelected","lastSelectedKey","_manager$firstSelecte","firstSelectedKey","onBlur","useEffect","selectedKeys","size","values","value","focusSafely","handlers","onMouseDown","_useTypeSelect","mergeProps","tabIndex","collectionProps","_babelRuntimeHelpersEsmExtends","useSelectableItem","shouldSelectOnPressUp","isVirtualized","onSelect","select","childFocusStrategy","itemProps","onPressStart","pointerType","onPressUp","onPress","ListKeyboardDelegate","collection","disabledKeys","collator","_classCallCheck","_createClass","getKeyAfter","item","getItem","type","has","getKeyBefore","querySelector","menu","pageY","Math","max","offsetTop","offsetHeight","min","scrollHeight","fromKey","substring","textValue","slice","compare","useSelectableList","props","_props$selectOnFocus","useCollator","usage","sensitivity","useMemo","element","$a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView","_useSelectableCollect","listProps","scrollIntoView","scrollView","offsetX","$a09ba753e08b703267f2392f7fc8e96$var$relativeOffset","offsetY","width","offsetWidth","height","x","scrollLeft","y","scrollTop","maxX","maxY","relativeOffset","ancestor","child","axis","prop","sum","offsetParent"],"sources":["E:\\Login-UI-UX-React-Native\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useTypeSelect.ts","E:\\Login-UI-UX-React-Native\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableCollection.ts","E:\\Login-UI-UX-React-Native\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableItem.ts","E:\\Login-UI-UX-React-Native\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\ListKeyboardDelegate.ts","E:\\Login-UI-UX-React-Native\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableList.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, Key, KeyboardEvent, useRef} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface TypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\ninterface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: TypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent, HTMLAttributes, Key, KeyboardEvent, RefObject, useEffect} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {focusWithoutScrolling, isMac, mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nfunction isCtrlKeyPressed(e: KeyboardEvent) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: SelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = false,\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false\n  } = options;\n  let {direction} = useLocale();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Let child element (e.g. menu button) handle the event if the Alt key is pressed.\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (e.altKey || !ref.current.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: HTMLElement;\n            let last: HTMLElement;\n            do {\n              last = walker.lastChild() as HTMLElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        manager.setFocusedKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        manager.setFocusedKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  useEffect(() => {\n    if (autoFocus) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from '@react-aria/focus';\nimport {HTMLAttributes, Key, RefObject, useEffect} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressEvent} from '@react-types/shared';\nimport {PressProps} from '@react-aria/interactions';\n\ninterface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean\n}\n\ninterface SelectableItemAria {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: HTMLAttributes<HTMLElement> & PressProps\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus\n  } = options;\n\n  let onSelect = (e: PressEvent | PointerEvent) => manager.select(key, e);\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  let isFocused = key === manager.focusedKey;\n  useEffect(() => {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  if (shouldSelectOnPressUp) {\n    itemProps.onPressStart = (e) => {\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemProps.onPressUp = (e) => {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n  } else {\n    // On touch, it feels strange to select on touch down, so we special case this.\n    itemProps.onPressStart = (e) => {\n      if (e.pointerType !== 'touch') {\n        onSelect(e);\n      }\n    };\n\n    itemProps.onPress = (e) => {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  return {\n    itemProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {HTMLAttributes, Key, RefObject, useEffect, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: SelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && selectionManager.focusedKey && ref?.current) {\n      let element = ref.current.querySelector(`[data-key=\"${selectionManager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(ref.current, element);\n      }\n    }\n  }, [isVirtualized, ref, selectionManager.focusedKey]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nfunction scrollIntoView(scrollView: HTMLElement, element: HTMLElement) {\n  let offsetX = relativeOffset(scrollView, element, 'left');\n  let offsetY = relativeOffset(scrollView, element, 'top');\n  let width = element.offsetWidth;\n  let height = element.offsetHeight;\n  let x = scrollView.scrollLeft;\n  let y = scrollView.scrollTop;\n  let maxX = x + scrollView.offsetWidth;\n  let maxY = y + scrollView.offsetHeight;\n\n  if (offsetX <= x) {\n    x = offsetX;\n  } else if (offsetX + width > maxX) {\n    x += offsetX + width - maxX;\n  }\n  if (offsetY <= y) {\n    y = offsetY;\n  } else if (offsetY + height > maxY) {\n    y += offsetY + height - maxY;\n  }\n\n  scrollView.scrollLeft = x;\n  scrollView.scrollTop = y;\n}\n\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */\nfunction relativeOffset(ancestor: HTMLElement, child: HTMLElement, axis: 'left'|'top') {\n  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';\n  let sum = 0;\n  while (child.offsetParent) {\n    sum += child[prop];\n    if (child.offsetParent === ancestor) {\n      // Stop once we have found the ancestor we are interested in.\n      break;\n    } else if (child.offsetParent.contains(ancestor)) {\n      // If the ancestor is not `position:relative`, then we stop at \n      // _its_ offset parent, and we subtract off _its_ offset, so that\n      // we end up with the proper offset from child to ancestor.\n      sum -= ancestor[prop];\n      break;\n    }\n    child = child.offsetParent as HTMLElement;\n  }\n  return sum;\n}\n"],"mappings":";;;;;;;OAyCO,SAASA,aAATA,CAAuBC,OAAvB,EAAmE;EACxE,IAAKC,gBAAD,GAAqDD,OAAzD,CAAKC,gBAAD;IAAmBC,gBAAnB,GAAqDF,OAAzD,CAAuBE,gBAAnB;IAAqCC,YAAA,GAAgBH,OAAzD,CAAyCG,YAAA;EACzC,IAAIC,KAAK,GAAGC,MAAM,CAAC;IACjBC,MAAM,EAAE,EADS;IAEjBC,OAAO,EAAE;EAFQ,CAAD,CAAN,CAGTC,OAHH;EAKA,IAAIC,SAAS,GAAI,SAAbA,SAASA,CAAIC,CAAD,EAAsB;IACpC,IAAIC,SAAS,GAAGC,qDAAe,CAACF,CAAC,CAACG,GAAH,CAA/B;IACA,IAAI,CAACF,SAAD,IAAcD,CAAC,CAACI,OAAhB,IAA2BJ,CAAC,CAACK,OAAjC,EAA0C;MACxC;IACD;IAMD,IAAIJ,SAAS,KAAK,GAAd,IAAqBP,KAAK,CAACE,MAAN,CAAaU,IAAb,GAAoBC,MAApB,GAA6B,CAAtD,EAAyD;MACvDP,CAAC,CAACQ,cAAF;MACA,IAAI,EAAE,yBAAyBR,CAA3B,CAAJ,EAAmC;QACjCA,CAAC,CAACS,eAAF;MACD;IACF;IAEDf,KAAK,CAACE,MAAN,IAAgBK,SAAhB;IAIA,IAAIE,GAAG,GAAGZ,gBAAgB,CAACmB,eAAjB,CAAiChB,KAAK,CAACE,MAAvC,EAA+CJ,gBAAgB,CAACmB,UAAhE,CAAV;IAGA,IAAIR,GAAG,IAAI,IAAX,EAAiB;MACfA,GAAG,GAAGZ,gBAAgB,CAACmB,eAAjB,CAAiChB,KAAK,CAACE,MAAvC,CAAN;IACD;IAED,IAAIO,GAAG,IAAI,IAAX,EAAiB;MACfX,gBAAgB,CAACoB,aAAjB,CAA+BT,GAA/B;MACA,IAAIV,YAAJ,EAAkB;QAChBA,YAAY,CAACU,GAAD,CAAZ;MACD;IACF;IAEDU,YAAY,CAACnB,KAAK,CAACG,OAAP,CAAZ;IACAH,KAAK,CAACG,OAAN,GAAgBiB,UAAU,CAAC,YAAM;MAC/BpB,KAAK,CAACE,MAAN,GAAe,EAAf;IACD,CAFyB,EAEvB,GAFuB,CAA1B;EAGD,CAvCD;EAyCA,OAAO;IACLmB,eAAe,EAAE;MAGfC,gBAAgB,EAAEzB,gBAAgB,CAACmB,eAAjB,GAAmCX,SAAnC,GAA+C;IAHlD;EADZ,CAAP;AAOD;AAED,SAASG,qDAATe,CAAyBd,GAAzB,EAAsC;EAKpC,IAAIA,GAAG,CAACI,MAAJ,KAAe,CAAf,IAAoB,CAAC,UAAUW,IAAV,CAAef,GAAf,CAAzB,EAA8C;IAC5C,OAAOA,GAAP;EACD;EAED,OAAO,EAAP;AACD;ACxFD,SAASgB,qDAATC,CAA0BpB,CAA1B,EAA4C;EAC1C,IAAIqB,KAAK,EAAT,EAAa;IACX,OAAOrB,CAAC,CAACK,OAAT;EACD;EAED,OAAOL,CAAC,CAACI,OAAT;AACD;OA+DM,SAASkB,uBAATA,CAAiChC,OAAjC,EAAiG;EACtG,IACoBiC,OADhB,GAYAjC,OAZJ,CACEE,gBAAgB;IACEgC,QAFhB,GAYAlC,OAZJ,CAEEC,gBAAgB;IAChBkC,GAHE,GAYAnC,OAZJ,CAGEmC,GAHE;IAAAC,kBAAA,GAYApC,OAZJ,CAIEqC,SAAS;IAATA,SAAS,GAAAD,kBAAA,cAAG,KAJV,GAAAA,kBAAA;IAAAE,qBAAA,GAYAtC,OAZJ,CAKEuC,eAAe;IAAfA,eAAe,GAAAD,qBAAA,cAAG,KALhB,GAAAA,qBAAA;IAAAE,qBAAA,GAYAxC,OAZJ,CAMEyC,sBAAsB;IAAtBA,sBAAsB,GAAAD,qBAAA,cAAG,KANvB,GAAAA,qBAAA;IAAAE,qBAAA,GAYA1C,OAZJ,CAOE2C,iBAAiB;IAAjBA,iBAAiB,GAAAD,qBAAA,cAAG,KAPlB,GAAAA,qBAAA;IAAAE,qBAAA,GAYA5C,OAZJ,CAQE6C,aAAa;IAAbA,aAAa,GAAAD,qBAAA,cAAG,KARd,GAAAA,qBAAA;IAAAE,qBAAA,GAYA9C,OAZJ,CASE+C,iBAAiB;IAAjBA,iBAAiB,GAAAD,qBAAA,cAAG,KATlB,GAAAA,qBAAA;IAUFE,qBAVE,GAYAhD,OAZJ,CAUEgD,qBAVE;IAAAC,qBAAA,GAYAjD,OAZJ,CAWEkD,mBAAmB;IAAnBA,mBAAmB,GAAAD,qBAAA,cAAG,QAAAA,qBAAA;EAExB,IAAAE,UAAA,GAAkBC,SAAS,EAA3B;IAAKC,SAAA,GAAAF,UAAA,CAAAE,SAAA;EAEL,IAAI5C,SAAS,GAAI,SAAbA,SAASA,CAAIC,CAAD,EAAsB;IAIpC,IAAIA,CAAC,CAAC4C,MAAF,IAAY,CAACnB,GAAG,CAAC3B,OAAJ,CAAY+C,QAAZ,CAAqB7C,CAAC,CAAC8C,MAAvB,CAAjB,EAAgE;MAC9D;IACD;IAED,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAI5C,GAAD,EAAuB6C,UAAvB,EAAsD;MAC1E,IAAI7C,GAAG,IAAI,IAAX,EAAiB;QACfoB,OAAO,CAACX,aAAR,CAAsBT,GAAtB,EAA2B6C,UAA3B;QAEA,IAAIhD,CAAC,CAACiD,QAAF,IAAc1B,OAAO,CAAC2B,aAAR,KAA0B,UAA5C,EAAwD;UACtD3B,OAAO,CAAC4B,eAAR,CAAwBhD,GAAxB;QACD,CAFD,MAEO,IAAIgC,aAAJ,EAAmB;UACxBZ,OAAO,CAAC6B,gBAAR,CAAyBjD,GAAzB;QACD;MACF;IACF,CAVD;IAYA,QAAQH,CAAC,CAACG,GAAV;MACE,KAAK,WAAL;QAAkB;UAChB,IAAIqB,QAAQ,CAAC6B,WAAb,EAA0B;YACxBrD,CAAC,CAACQ,cAAF;YACA,IAAI8C,OAAO,GAAG/B,OAAO,CAACZ,UAAR,IAAsB,IAAtB,GACRa,QAAQ,CAAC6B,WAAT,CAAqB9B,OAAO,CAACZ,UAA7B,CADQ,GAERa,QAAQ,CAAC+B,WAFD,oBAER/B,QAAQ,CAAC+B,WAAT,EAFN;YAGA,IAAID,OAAO,IAAI,IAAX,IAAmBzB,eAAvB,EAAwC;cACtCyB,OAAO,GAAG9B,QAAQ,CAAC+B,WAAZ,oBAAG/B,QAAQ,CAAC+B,WAAT,CAAuBhC,OAAO,CAACZ,UAA/B,CAAV;YACD;YACDoC,aAAa,CAACO,OAAD,CAAb;UACD;UACD;QACD;MACD,KAAK,SAAL;QAAgB;UACd,IAAI9B,QAAQ,CAACgC,WAAb,EAA0B;YACxBxD,CAAC,CAACQ,cAAF;YACA,IAAI8C,QAAO,GAAG/B,OAAO,CAACZ,UAAR,IAAsB,IAAtB,GACRa,QAAQ,CAACgC,WAAT,CAAqBjC,OAAO,CAACZ,UAA7B,CADQ,GAERa,QAAQ,CAACiC,UAFD,oBAERjC,QAAQ,CAACiC,UAAT,EAFN;YAGA,IAAIH,QAAO,IAAI,IAAX,IAAmBzB,eAAvB,EAAwC;cACtCyB,QAAO,GAAG9B,QAAQ,CAACiC,UAAZ,oBAAGjC,QAAQ,CAACiC,UAAT,CAAsBlC,OAAO,CAACZ,UAA9B,CAAV;YACD;YACDoC,aAAa,CAACO,QAAD,CAAb;UACD;UACD;QACD;MACD,KAAK,WAAL;QAAkB;UAChB,IAAI9B,QAAQ,CAACkC,YAAb,EAA2B;YACzB1D,CAAC,CAACQ,cAAF;YACA,IAAI8C,SAAO,GAAG9B,QAAQ,CAACkC,YAAT,CAAsBnC,OAAO,CAACZ,UAA9B,CAAd;YACAoC,aAAa,CAACO,SAAD,EAAUX,SAAS,KAAK,KAAd,GAAsB,OAAtB,GAAgC,MAA1C,CAAb;UACD;UACD;QACD;MACD,KAAK,YAAL;QAAmB;UACjB,IAAInB,QAAQ,CAACmC,aAAb,EAA4B;YAC1B3D,CAAC,CAACQ,cAAF;YACA,IAAI8C,SAAO,GAAG9B,QAAQ,CAACmC,aAAT,CAAuBpC,OAAO,CAACZ,UAA/B,CAAd;YACAoC,aAAa,CAACO,SAAD,EAAUX,SAAS,KAAK,KAAd,GAAsB,MAAtB,GAA+B,OAAzC,CAAb;UACD;UACD;QACD;MACD,KAAK,MAAL;QACE,IAAInB,QAAQ,CAAC+B,WAAb,EAA0B;UACxBvD,CAAC,CAACQ,cAAF;UACA,IAAIoD,QAAQ,GAAGpC,QAAQ,CAAC+B,WAAT,CAAqBhC,OAAO,CAACZ,UAA7B,EAAyCQ,qDAAgB,CAACnB,CAAD,CAAzD,CAAf;UACAuB,OAAO,CAACX,aAAR,CAAsBgD,QAAtB;UACA,IAAIzC,qDAAgB,CAACnB,CAAD,CAAhB,IAAuBA,CAAC,CAACiD,QAAzB,IAAqC1B,OAAO,CAAC2B,aAAR,KAA0B,UAAnE,EAA+E;YAC7E3B,OAAO,CAAC4B,eAAR,CAAwBS,QAAxB;UACD,CAFD,MAEO,IAAIzB,aAAJ,EAAmB;YACxBZ,OAAO,CAAC6B,gBAAR,CAAyBQ,QAAzB;UACD;QACF;QACD;MACF,KAAK,KAAL;QACE,IAAIpC,QAAQ,CAACiC,UAAb,EAAyB;UACvBzD,CAAC,CAACQ,cAAF;UACA,IAAIqD,OAAO,GAAGrC,QAAQ,CAACiC,UAAT,CAAoBlC,OAAO,CAACZ,UAA5B,EAAwCQ,qDAAgB,CAACnB,CAAD,CAAxD,CAAd;UACAuB,OAAO,CAACX,aAAR,CAAsBiD,OAAtB;UACA,IAAI1C,qDAAgB,CAACnB,CAAD,CAAhB,IAAuBA,CAAC,CAACiD,QAAzB,IAAqC1B,OAAO,CAAC2B,aAAR,KAA0B,UAAnE,EAA+E;YAC7E3B,OAAO,CAAC4B,eAAR,CAAwBU,OAAxB;UACD,CAFD,MAEO,IAAI1B,aAAJ,EAAmB;YACxBZ,OAAO,CAAC6B,gBAAR,CAAyBS,OAAzB;UACD;QACF;QACD;MACF,KAAK,UAAL;QACE,IAAIrC,QAAQ,CAACsC,eAAb,EAA8B;UAC5B9D,CAAC,CAACQ,cAAF;UACA,IAAI8C,SAAO,GAAG9B,QAAQ,CAACsC,eAAT,CAAyBvC,OAAO,CAACZ,UAAjC,CAAd;UACAoC,aAAa,CAACO,SAAD,CAAb;QACD;QACD;MACF,KAAK,QAAL;QACE,IAAI9B,QAAQ,CAACuC,eAAb,EAA8B;UAC5B/D,CAAC,CAACQ,cAAF;UACA,IAAI8C,SAAO,GAAG9B,QAAQ,CAACuC,eAAT,CAAyBxC,OAAO,CAACZ,UAAjC,CAAd;UACAoC,aAAa,CAACO,SAAD,CAAb;QACD;QACD;MACF,KAAK,GAAL;QACE,IAAInC,qDAAgB,CAACnB,CAAD,CAAhB,IAAuBuB,OAAO,CAAC2B,aAAR,KAA0B,UAAjD,IAA+DjB,iBAAiB,KAAK,IAAzF,EAA+F;UAC7FjC,CAAC,CAACQ,cAAF;UACAe,OAAO,CAACyC,SAAR;QACD;QACD;MACF,KAAK,QAAL;QACEhE,CAAC,CAACQ,cAAF;QACA,IAAI,CAACuB,sBAAL,EAA6B;UAC3BR,OAAO,CAAC0C,cAAR;QACD;QACD;MACF,KAAK,KAAL;QAAY;UACV,IAAI,CAACzB,mBAAL,EAA0B;YAOxB,IAAIxC,CAAC,CAACiD,QAAN,EAAgB;cACdxB,GAAG,CAAC3B,OAAJ,CAAYoE,KAAZ;YACD,CAFD,MAEO;cACL,IAAIC,MAAM,GAAGC,sBAAsB,CAAC3C,GAAG,CAAC3B,OAAL,EAAc;gBAACuE,QAAQ,EAAE;cAAX,CAAd,CAAnC;cACA,IAAIC,IAAJ;cACA,IAAIC,IAAJ;cACA,GAAG;gBACDA,IAAI,GAAGJ,MAAM,CAACK,SAAP,EAAP;gBACA,IAAID,IAAJ,EAAU;kBACRD,IAAI,GAAGC,IAAP;gBACD;cACF,CALD,QAKSA,IALT;cAOA,IAAID,IAAI,IAAI,CAACA,IAAI,CAACzB,QAAL,CAAc4B,QAAQ,CAACC,aAAvB,CAAb,EAAoD;gBAClDC,qBAAqB,CAACL,IAAD,CAArB;cACD;YACF;YACD;UACD;QACF;IAxHH;EA0HD,CA9ID;EAgJA,IAAIM,OAAO,GAAI,SAAXA,OAAOA,CAAI5E,CAAD,EAAmB;IAC/B,IAAIuB,OAAO,CAACsD,SAAZ,EAAuB;MAErB,IAAI,CAAC7E,CAAC,CAAC8E,aAAF,CAAgBjC,QAAhB,CAAyB7C,CAAC,CAAC8C,MAA3B,CAAL,EAAyC;QACvCvB,OAAO,CAACwD,UAAR,CAAmB,KAAnB;MACD;MAED;IACD;IAGD,IAAI,CAAC/E,CAAC,CAAC8E,aAAF,CAAgBjC,QAAhB,CAAyB7C,CAAC,CAAC8C,MAA3B,CAAL,EAAyC;MACvC;IACD;IAEDvB,OAAO,CAACwD,UAAR,CAAmB,IAAnB;IAEA,IAAIxD,OAAO,CAACZ,UAAR,IAAsB,IAA1B,EAAgC;MAI9B,IAAIqE,aAAa,GAAGhF,CAAC,CAACgF,aAAtB;MACA,IAAIA,aAAa,IAAKhF,CAAC,CAAC8E,aAAF,CAAgBG,uBAAhB,CAAwCD,aAAxC,IAAyDE,IAAI,CAACC,2BAApF,EAAkH;QAAA,IAAAC,qBAAA;QAChH7D,OAAO,CAACX,aAAR,EAAAwE,qBAAA,GAAsB7D,OAAO,CAAC8D,eAA9B,YAAAD,qBAAA,GAAiD5D,QAAQ,CAACiC,UAAT,EAAjD;MACD,CAFD,MAEO;QAAA,IAAA6B,qBAAA;QACL/D,OAAO,CAACX,aAAR,EAAA0E,qBAAA,GAAsB/D,OAAO,CAACgE,gBAA9B,YAAAD,qBAAA,GAAkD9D,QAAQ,CAAC+B,WAAT,EAAlD;MACD;IACF;EACF,CA5BD;EA8BA,IAAIiC,MAAM,GAAI,SAAVA,MAAMA,CAAIxF,CAAD,EAAO;IAElB,IAAI,CAACA,CAAC,CAAC8E,aAAF,CAAgBjC,QAAhB,CAAyB7C,CAAC,CAACgF,aAA3B,CAAL,EAA+D;MAC7DzD,OAAO,CAACwD,UAAR,CAAmB,KAAnB;IACD;EACF,CALD;EAOAU,SAAS,CAAC,YAAM;IACd,IAAI9D,SAAJ,EAAe;MACb,IAAIhB,UAAU,GAAG,IAAjB;MAGA,IAAIgB,SAAS,KAAK,OAAlB,EAA2B;QACzBhB,UAAU,GAAGa,QAAQ,CAAC+B,WAAT,EAAb;MACD;MAAC,IAAI5B,SAAS,KAAK,MAAlB,EAA0B;QAC1BhB,UAAU,GAAGa,QAAQ,CAACiC,UAAT,EAAb;MACD;MAGD,IAAIiC,YAAY,GAAGnE,OAAO,CAACmE,YAA3B;MACA,IAAIA,YAAY,CAACC,IAAjB,EAAuB;QACrBhF,UAAU,GAAG+E,YAAY,CAACE,MAAb,GAAsBtB,IAAtB,GAA6BuB,KAA1C;MACD;MAEDtE,OAAO,CAACwD,UAAR,CAAmB,IAAnB;MACAxD,OAAO,CAACX,aAAR,CAAsBD,UAAtB;MAGA,IAAIA,UAAU,IAAI,IAAd,IAAsB,CAAC2B,qBAA3B,EAAkD;QAChDwD,WAAW,CAACrE,GAAG,CAAC3B,OAAL,CAAX;MACD;IACF;EAEF,CA1BQ,EA0BN,EA1BM,CAAT;EA4BA,IAAIiG,QAAQ,GAAG;IACbhG,SADa,EACbA,SADa;IAEb6E,OAFa,EAEbA,OAFa;IAGbY,MAHa,EAGbA,MAHa;IAIbQ,WAAW,WAAAA,YAAChG,CAAD,EAAI;MAEb,IAAIA,CAAC,CAAC8E,aAAF,CAAgBjC,QAAhB,CAAyB7C,CAAC,CAAC8C,MAA3B,CAAJ,EAAwC;QAEtC9C,CAAC,CAACQ,cAAF;MACD;IACF;EAVY,CAAf;EAaA,IAAAyF,cAAA,GAAwB5G,aAAA,CAAc;MACpCE,gBAAgB,EAAEiC,QADkB;MAEpChC,gBAAgB,EAAE+B;IAFkB,CAAd,CAAxB;IAAKR,eAAA,GAAAkF,cAAA,CAAAlF,eAAA;EAKL,IAAI,CAACsB,iBAAL,EAAwB;IACtB0D,QAAQ,GAAGG,UAAU,CAACnF,eAAD,EAAkBgF,QAAlB,CAArB;EACD;EAMD,IAAII,QAAJ;EACA,IAAI,CAAC7D,qBAAL,EAA4B;IAC1B6D,QAAQ,GAAG5E,OAAO,CAACZ,UAAR,IAAsB,IAAtB,GAA6B,CAA7B,GAAiC,CAAC,CAA7C;EACD;EAED,OAAO;IACLyF,eAAe,EAAAC,8BAAA,KACVN,QADU;MAEbI,QAAA,EAAAA;IAFa;EADV,CAAP;AAMD;OCnSM,SAASG,iBAATA,CAA2BhH,OAA3B,EAA+E;EACpF,IACoBiC,OADhB,GAQAjC,OARJ,CACEE,gBAAgB;IAChBW,GAFE,GAQAb,OARJ,CAEEa,GAFE;IAGFsB,GAHE,GAQAnC,OARJ,CAGEmC,GAHE;IAIF8E,qBAJE,GAQAjH,OARJ,CAIEiH,qBAJE;IAKFC,aALE,GAQAlH,OARJ,CAKEkH,aALE;IAMFlE,qBANE,GAQAhD,OARJ,CAMEgD,qBANE;IAOF4B,KAAA,GACE5E,OARJ,CAOE4E,KAAA;EAGF,IAAIuC,QAAQ,GAAI,SAAZA,QAAQA,CAAIzG,CAAD;IAAA,OAAkCuB,OAAO,CAACmF,MAAR,CAAevG,GAAf,EAAoBH,CAApB,CAAjD;EAAA;EAGA,IAAI6E,SAAS,GAAG1E,GAAG,KAAKoB,OAAO,CAACZ,UAAhC;EACA8E,SAAS,CAAC,YAAM;IACd,IAAIZ,SAAS,IAAItD,OAAO,CAACsD,SAArB,IAAkC,CAACvC,qBAAnC,IAA4DmC,QAAQ,CAACC,aAAT,KAA2BjD,GAAG,CAAC3B,OAA/F,EAAwG;MACtG,IAAIoE,KAAJ,EAAW;QACTA,KAAK;MACN,CAFD,MAEO;QACL4B,WAAW,CAACrE,GAAG,CAAC3B,OAAL,CAAX;MACD;IACF;EACF,CARQ,EAQN,CAAC2B,GAAD,EAAMoD,SAAN,EAAiBtD,OAAO,CAACZ,UAAzB,EAAqCY,OAAO,CAACoF,kBAA7C,EAAiEpF,OAAO,CAACsD,SAAzE,EAAoFvC,qBAApF,CARM,CAAT;EAaA,IAAIsE,SAA0C,GAAG,EAAjD;EACA,IAAI,CAACtE,qBAAL,EAA4B;IAC1BsE,SAAS,GAAG;MACVT,QAAQ,EAAEtB,SAAS,GAAG,CAAH,GAAO,CAAC,CADjB;MAEVD,OAAO,WAAAA,QAAC5E,CAAD,EAAI;QACT,IAAIA,CAAC,CAAC8C,MAAF,KAAarB,GAAG,CAAC3B,OAArB,EAA8B;UAC5ByB,OAAO,CAACX,aAAR,CAAsBT,GAAtB;QACD;MACF;IANS,CAAZ;EAQD;EASD,IAAIoG,qBAAJ,EAA2B;IACzBK,SAAS,CAACC,YAAV,GAA0B,UAAA7G,CAAD,EAAO;MAC9B,IAAIA,CAAC,CAAC8G,WAAF,KAAkB,UAAtB,EAAkC;QAChCL,QAAQ,CAACzG,CAAD,CAAR;MACD;IACF,CAJD;IAMA4G,SAAS,CAACG,SAAV,GAAuB,UAAA/G,CAAD,EAAO;MAC3B,IAAIA,CAAC,CAAC8G,WAAF,KAAkB,UAAtB,EAAkC;QAChCL,QAAQ,CAACzG,CAAD,CAAR;MACD;IACF,CAJD;EAKD,CAZD,MAYO;IAEL4G,SAAS,CAACC,YAAV,GAA0B,UAAA7G,CAAD,EAAO;MAC9B,IAAIA,CAAC,CAAC8G,WAAF,KAAkB,OAAtB,EAA+B;QAC7BL,QAAQ,CAACzG,CAAD,CAAR;MACD;IACF,CAJD;IAMA4G,SAAS,CAACI,OAAV,GAAqB,UAAAhH,CAAD,EAAO;MACzB,IAAIA,CAAC,CAAC8G,WAAF,KAAkB,OAAtB,EAA+B;QAC7BL,QAAQ,CAACzG,CAAD,CAAR;MACD;IACF,CAJD;EAKD;EAED,IAAI,CAACwG,aAAL,EAAoB;IAClBI,SAAS,CAAC,UAAD,CAAT,GAAwBzG,GAAxB;EACD;EAED,OAAO;IACLyG,SAAA,EAAAA;EADK,CAAP;AAGD;WC9HYK,oBAAN;EAML,SAAAA,qBAAYC,UAAD,EAAkCC,YAAlC,EAA0D1F,GAA1D,EAAuF2F,QAAvF,EAAiH;IAAAC,eAAA,OAAAJ,oBAAA;IAAA,KALpHC,UAKoH;IAAA,KAJpHC,YAIoH;IAAA,KAHpH1F,GAGoH;IAAA,KAFpH2F,QAEoH;IAC1H,KAAKF,UAAL,GAAkBA,UAAlB;IACA,KAAKC,YAAL,GAAoBA,YAApB;IACA,KAAK1F,GAAL,GAAWA,GAAX;IACA,KAAK2F,QAAL,GAAgBA,QAAhB;EACD;EAAAE,YAAA,CAAAL,oBAAA;IAAA9G,GAAA;IAAA0F,KAAA,EAED,SAAAxC,YAAYlD,GAAD,EAAW;MACpBA,GAAG,GAAG,KAAK+G,UAAL,CAAgBK,WAAhB,CAA4BpH,GAA5B,CAAN;MACA,OAAOA,GAAG,IAAI,IAAd,EAAoB;QAClB,IAAIqH,IAAI,GAAG,KAAKN,UAAL,CAAgBO,OAAhB,CAAwBtH,GAAxB,CAAX;QACA,IAAIqH,IAAI,CAACE,IAAL,KAAc,MAAd,IAAwB,CAAC,KAAKP,YAAL,CAAkBQ,GAAlB,CAAsBxH,GAAtB,CAA7B,EAAyD;UACvD,OAAOA,GAAP;QACD;QAEDA,GAAG,GAAG,KAAK+G,UAAL,CAAgBK,WAAhB,CAA4BpH,GAA5B,CAAN;MACD;IACF;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAED,SAAArC,YAAYrD,GAAD,EAAW;MACpBA,GAAG,GAAG,KAAK+G,UAAL,CAAgBU,YAAhB,CAA6BzH,GAA7B,CAAN;MACA,OAAOA,GAAG,IAAI,IAAd,EAAoB;QAClB,IAAIqH,IAAI,GAAG,KAAKN,UAAL,CAAgBO,OAAhB,CAAwBtH,GAAxB,CAAX;QACA,IAAIqH,IAAI,CAACE,IAAL,KAAc,MAAd,IAAwB,CAAC,KAAKP,YAAL,CAAkBQ,GAAlB,CAAsBxH,GAAtB,CAA7B,EAAyD;UACvD,OAAOA,GAAP;QACD;QAEDA,GAAG,GAAG,KAAK+G,UAAL,CAAgBU,YAAhB,CAA6BzH,GAA7B,CAAN;MACD;IACF;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAED,SAAAtC,YAAA,EAAc;MACZ,IAAIpD,GAAG,GAAG,KAAK+G,UAAL,CAAgB3D,WAAhB,EAAV;MACA,OAAOpD,GAAG,IAAI,IAAd,EAAoB;QAClB,IAAIqH,IAAI,GAAG,KAAKN,UAAL,CAAgBO,OAAhB,CAAwBtH,GAAxB,CAAX;QACA,IAAIqH,IAAI,CAACE,IAAL,KAAc,MAAd,IAAwB,CAAC,KAAKP,YAAL,CAAkBQ,GAAlB,CAAsBxH,GAAtB,CAA7B,EAAyD;UACvD,OAAOA,GAAP;QACD;QAEDA,GAAG,GAAG,KAAK+G,UAAL,CAAgBK,WAAhB,CAA4BpH,GAA5B,CAAN;MACD;IACF;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAED,SAAApC,WAAA,EAAa;MACX,IAAItD,GAAG,GAAG,KAAK+G,UAAL,CAAgBzD,UAAhB,EAAV;MACA,OAAOtD,GAAG,IAAI,IAAd,EAAoB;QAClB,IAAIqH,IAAI,GAAG,KAAKN,UAAL,CAAgBO,OAAhB,CAAwBtH,GAAxB,CAAX;QACA,IAAIqH,IAAI,CAACE,IAAL,KAAc,MAAd,IAAwB,CAAC,KAAKP,YAAL,CAAkBQ,GAAlB,CAAsBxH,GAAtB,CAA7B,EAAyD;UACvD,OAAOA,GAAP;QACD;QAEDA,GAAG,GAAG,KAAK+G,UAAL,CAAgBU,YAAhB,CAA6BzH,GAA7B,CAAN;MACD;IACF;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAEO,SAAA4B,QAAQtH,GAAhB,EAAuC;MACrC,OAAO,KAAKsB,GAAL,CAAS3B,OAAT,CAAiB+H,aAAjB,kBAA6C1H,GAA7C,SAAP;IACD;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAED,SAAA9B,gBAAgB5D,GAAD,EAAW;MACxB,IAAI2H,IAAI,GAAG,KAAKrG,GAAL,CAAS3B,OAApB;MACA,IAAI0H,IAAI,GAAG,KAAKC,OAAL,CAAatH,GAAb,CAAX;MACA,IAAI,CAACqH,IAAL,EAAW;QACT,OAAO,IAAP;MACD;MAED,IAAIO,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYT,IAAI,CAACU,SAAL,GAAiBV,IAAI,CAACW,YAAtB,GAAqCL,IAAI,CAACK,YAAtD,CAAZ;MAEA,OAAOX,IAAI,IAAIA,IAAI,CAACU,SAAL,GAAiBH,KAAhC,EAAuC;QACrC5H,GAAG,GAAG,KAAKqD,WAAL,CAAiBrD,GAAjB,CAAN;QACAqH,IAAI,GAAG,KAAKC,OAAL,CAAatH,GAAb,CAAP;MACD;MAED,OAAOA,GAAP;IACD;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAED,SAAA/B,gBAAgB3D,GAAD,EAAW;MACxB,IAAI2H,IAAI,GAAG,KAAKrG,GAAL,CAAS3B,OAApB;MACA,IAAI0H,IAAI,GAAG,KAAKC,OAAL,CAAatH,GAAb,CAAX;MACA,IAAI,CAACqH,IAAL,EAAW;QACT,OAAO,IAAP;MACD;MAED,IAAIO,KAAK,GAAGC,IAAI,CAACI,GAAL,CAASN,IAAI,CAACO,YAAd,EAA4Bb,IAAI,CAACU,SAAL,GAAiBV,IAAI,CAACW,YAAtB,GAAqCL,IAAI,CAACK,YAAtE,CAAZ;MAEA,OAAOX,IAAI,IAAIA,IAAI,CAACU,SAAL,GAAiBH,KAAhC,EAAuC;QACrC5H,GAAG,GAAG,KAAKkD,WAAL,CAAiBlD,GAAjB,CAAN;QACAqH,IAAI,GAAG,KAAKC,OAAL,CAAatH,GAAb,CAAP;MACD;MAED,OAAOA,GAAP;IACD;EAAA;IAAAA,GAAA;IAAA0F,KAAA,EAED,SAAAnF,gBAAgBd,MAAD,EAAiB0I,OAAjB,EAAgC;MAC7C,IAAI,CAAC,KAAKlB,QAAV,EAAoB;QAClB,OAAO,IAAP;MACD;MAED,IAAIF,UAAU,GAAG,KAAKA,UAAtB;MACA,IAAI/G,GAAG,GAAGmI,OAAO,IAAI,KAAK/E,WAAL,EAArB;MACA,OAAOpD,GAAG,IAAI,IAAd,EAAoB;QAClB,IAAIqH,IAAI,GAAGN,UAAU,CAACO,OAAX,CAAmBtH,GAAnB,CAAX;QACA,IAAIoI,SAAS,GAAGf,IAAI,CAACgB,SAAL,CAAeC,KAAf,CAAqB,CAArB,EAAwB7I,MAAM,CAACW,MAA/B,CAAhB;QACA,IAAIiH,IAAI,CAACgB,SAAL,IAAkB,KAAKpB,QAAL,CAAcsB,OAAd,CAAsBH,SAAtB,EAAiC3I,MAAjC,MAA6C,CAAnE,EAAsE;UACpE,OAAOO,GAAP;QACD;QAEDA,GAAG,GAAG,KAAKkD,WAAL,CAAiBlD,GAAjB,CAAN;MACD;MAED,OAAO,IAAP;IACD;EAAA;EAAA,OAAA8G,oBAAA;AAAA;OC3CI,SAAS0B,iBAATA,CAA2BC,KAA3B,EAA6E;EAClF,IACEpJ,gBADE,GAcAoJ,KAdJ,CACEpJ,gBADE;IAEF0H,UAFE,GAcA0B,KAdJ,CAEE1B,UAFE;IAGFC,YAHE,GAcAyB,KAdJ,CAGEzB,YAHE;IAIF1F,GAJE,GAcAmH,KAdJ,CAIEnH,GAJE;IAKFlC,gBALE,GAcAqJ,KAdJ,CAKErJ,gBALE;IAMFoC,SANE,GAcAiH,KAdJ,CAMEjH,SANE;IAOFE,eAPE,GAcA+G,KAdJ,CAOE/G,eAPE;IAQF2E,aARE,GAcAoC,KAdJ,CAQEpC,aARE;IASFzE,sBATE,GAcA6G,KAdJ,CASE7G,sBATE;IAAA8G,oBAAA,GAcAD,KAdJ,CAUEzG,aAAa;IAAbA,aAAa,GAAA0G,oBAAA,cAAG,KAVd,GAAAA,oBAAA;IAWFxG,iBAXE,GAcAuG,KAdJ,CAWEvG,iBAXE;IAYFC,qBAZE,GAcAsG,KAdJ,CAYEtG,qBAZE;IAaFE,mBAAA,GACEoG,KAdJ,CAaEpG,mBAAA;EAKF,IAAI4E,QAAQ,GAAG0B,WAAW,CAAC;IAACC,KAAK,EAAE,QAAR;IAAkBC,WAAW,EAAE;EAA/B,CAAD,CAA1B;EACA,IAAIxH,QAAQ,GAAGyH,OAAO,CAAC;IAAA,OAAM1J,gBAAgB,IAAI,IAAA0H,oBAAA,CAAyBC,UAAzB,EAAqCC,YAArC,EAAmD1F,GAAnD,EAAwD2F,QAAxD,CAA3B;EAAA,GAA8F,CAAC7H,gBAAD,EAAmB2H,UAAnB,EAA+BC,YAA/B,EAA6C1F,GAA7C,EAAkD2F,QAAlD,CAA9F,CAAtB;EAIA3B,SAAS,CAAC,YAAM;IACd,IAAI,CAACe,aAAD,IAAkBhH,gBAAgB,CAACmB,UAAnC,IAAiDc,GAAjD,YAAiDA,GAAG,CAAE3B,OAA1D,EAAmE;MACjE,IAAIoJ,OAAO,GAAGzH,GAAG,CAAC3B,OAAJ,CAAY+H,aAAZ,kBAAwCrI,gBAAgB,CAACmB,UAAzD,SAAd;MACA,IAAIuI,OAAJ,EAAa;QACXC,mDAAc,CAAC1H,GAAG,CAAC3B,OAAL,EAAcoJ,OAAd,CAAd;MACD;IACF;EACF,CAPQ,EAON,CAAC1C,aAAD,EAAgB/E,GAAhB,EAAqBjC,gBAAgB,CAACmB,UAAtC,CAPM,CAAT;EASA,IAAAyI,qBAAA,GAAwB9H,uBAAA,CAAwB;MAC9CG,GAD8C,EAC9CA,GAD8C;MAE9CjC,gBAF8C,EAE9CA,gBAF8C;MAG9CD,gBAAgB,EAAEiC,QAH4B;MAI9CG,SAJ8C,EAI9CA,SAJ8C;MAK9CE,eAL8C,EAK9CA,eAL8C;MAM9CE,sBAN8C,EAM9CA,sBAN8C;MAO9CI,aAP8C,EAO9CA,aAP8C;MAQ9CE,iBAR8C,EAQ9CA,iBAR8C;MAS9CC,qBAT8C,EAS9CA,qBAT8C;MAU9CE,mBAAA,EAAAA;IAV8C,CAAxB,CAAxB;IAAK4D,eAAA,GAAAgD,qBAAA,CAAAhD,eAAA;EAaL,OAAO;IACLiD,SAAS,EAAEjD;EADN,CAAP;AAGD;AAOD,SAAS+C,mDAATG,CAAwBC,UAAxB,EAAiDL,OAAjD,EAAuE;EACrE,IAAIM,OAAO,GAAGC,mDAAc,CAACF,UAAD,EAAaL,OAAb,EAAsB,MAAtB,CAA5B;EACA,IAAIQ,OAAO,GAAGD,mDAAc,CAACF,UAAD,EAAaL,OAAb,EAAsB,KAAtB,CAA5B;EACA,IAAIS,KAAK,GAAGT,OAAO,CAACU,WAApB;EACA,IAAIC,MAAM,GAAGX,OAAO,CAACf,YAArB;EACA,IAAI2B,CAAC,GAAGP,UAAU,CAACQ,UAAnB;EACA,IAAIC,CAAC,GAAGT,UAAU,CAACU,SAAnB;EACA,IAAIC,IAAI,GAAGJ,CAAC,GAAGP,UAAU,CAACK,WAA1B;EACA,IAAIO,IAAI,GAAGH,CAAC,GAAGT,UAAU,CAACpB,YAA1B;EAEA,IAAIqB,OAAO,IAAIM,CAAf,EAAkB;IAChBA,CAAC,GAAGN,OAAJ;EACD,CAFD,MAEO,IAAIA,OAAO,GAAGG,KAAV,GAAkBO,IAAtB,EAA4B;IACjCJ,CAAC,IAAIN,OAAO,GAAGG,KAAV,GAAkBO,IAAvB;EACD;EACD,IAAIR,OAAO,IAAIM,CAAf,EAAkB;IAChBA,CAAC,GAAGN,OAAJ;EACD,CAFD,MAEO,IAAIA,OAAO,GAAGG,MAAV,GAAmBM,IAAvB,EAA6B;IAClCH,CAAC,IAAIN,OAAO,GAAGG,MAAV,GAAmBM,IAAxB;EACD;EAEDZ,UAAU,CAACQ,UAAX,GAAwBD,CAAxB;EACAP,UAAU,CAACU,SAAX,GAAuBD,CAAvB;AACD;AAMD,SAASP,mDAATW,CAAwBC,QAAxB,EAA+CC,KAA/C,EAAmEC,IAAnE,EAAuF;EACrF,IAAMC,IAAI,GAAGD,IAAI,KAAK,MAAT,GAAkB,YAAlB,GAAiC,WAA9C;EACA,IAAIE,GAAG,GAAG,CAAV;EACA,OAAOH,KAAK,CAACI,YAAb,EAA2B;IACzBD,GAAG,IAAIH,KAAK,CAACE,IAAD,CAAZ;IACA,IAAIF,KAAK,CAACI,YAAN,KAAuBL,QAA3B,EAAqC;MAEnC;IACD,CAHD,MAGO,IAAIC,KAAK,CAACI,YAAN,CAAmB7H,QAAnB,CAA4BwH,QAA5B,CAAJ,EAA2C;MAIhDI,GAAG,IAAIJ,QAAQ,CAACG,IAAD,CAAf;MACA;IACD;IACDF,KAAK,GAAGA,KAAK,CAACI,YAAd;EACD;EACD,OAAOD,GAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}